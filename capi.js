
const L=1024*1024,D='capi_DB',S='cache';function b(s){return new Blob([s]).size;}function ns(n,k){return n?`${n}::${k}`:k;}const capi={p:null,g(){return this.p||(this.p=new Promise((r,j)=>{const q=indexedDB.open(D,1);q.onupgradeneeded=()=>q.result.createObjectStore(S);q.onsuccess=()=>r(q.result);q.onerror=()=>j(q.error);}));},async iSet(k,v,o,n){const db=await this.g();return new Promise((r,j)=>{const t=db.transaction(S,'readwrite');t.objectStore(S).put({value:v,expires:o&&o.ttl?Date.now()+o.ttl*1e3:null},ns(n,k));t.oncomplete=()=>r();t.onerror=()=>j();});},async iGet(k,n){const db=await this.g();return new Promise((r,j)=>{const t=db.transaction(S,'readonly'),req=t.objectStore(S).get(ns(n,k));req.onsuccess=()=>{const e=req.result;if(!e)return r(null);if(e.expires&&Date.now()>e.expires){t.objectStore(S).delete(ns(n,k));return r(null);}r(e.value);};req.onerror=()=>j();});},async iDel(k,n){const db=await this.g();return new Promise((r,j)=>{const t=db.transaction(S,'readwrite');t.objectStore(S).delete(ns(n,k));t.oncomplete=()=>r();t.onerror=()=>j();});},async iClear(ns){const db=await this.g();if(ns){const keys=await new Promise((r,j)=>{const req=db.transaction(S,'readonly').objectStore(S).getAllKeys();req.onsuccess=()=>r(req.result.filter(k=>k.startsWith(ns+'::')).map(k=>k.slice(ns.length+2)));req.onerror=()=>j();});await Promise.all(keys.map(k=>this.iDel(k,ns)));}else{return new Promise((r,j)=>{const t=db.transaction(S,'readwrite');t.objectStore(S).clear();t.oncomplete=()=>r();t.onerror=()=>j();});}},async iKeys(ns){const db=await this.g();return new Promise((r,j)=>{const req=db.transaction(S,'readonly').objectStore(S).getAllKeys();req.onsuccess=()=>r(req.result.filter(k=>!ns||k.startsWith(ns+'::')).map(k=>ns?k.slice(ns.length+2):k));req.onerror=()=>j();});},async iHas(k,ns){return(await this.iGet(k,ns))!==null;},lSet(k,v,o,n){try{localStorage.setItem(ns(n,k),JSON.stringify({value:v,expires:o&&o.ttl?Date.now()+o.ttl*1e3:null}));}catch(e){throw e;}},lGet(k,n){const e=localStorage.getItem(ns(n,k));if(!e)return null;try{const d=JSON.parse(e);if(d.expires&&Date.now()>d.expires){localStorage.removeItem(ns(n,k));return null;}return d.value;}catch{localStorage.removeItem(ns(n,k));return null;}},lDel(k,n){localStorage.removeItem(ns(n,k));},lClear(ns){if(ns){Object.keys(localStorage).forEach(k=>k.startsWith(ns+'::')&&localStorage.removeItem(k));}else localStorage.clear();},lKeys(ns){return Object.keys(localStorage).filter(k=>!ns||k.startsWith(ns+'::')).map(k=>ns?k.slice(ns.length+2):k);},lHas(k,ns){return this.lGet(k,ns)!==null;},async set(k,v,o={},ns){let s;try{s=JSON.stringify(v);}catch{return await this.iSet(k,v,o,ns);}const z=b(s);if((o&&o.ttl&&o.ttl>3600)||z>L)await this.iSet(k,v,o,ns);else try{this.lSet(k,v,o,ns);}catch{await this.iSet(k,v,o,ns);}},async get(k,ns){const l=this.lGet(k,ns);if(l!==null)return l;return await this.iGet(k,ns);},async delete(k,ns){this.lDel(k,ns);await this.iDel(k,ns);},async clear(ns){this.lClear(ns);await this.iClear(ns);},async keys(ns){return[...this.lKeys(ns),...await this.iKeys(ns)];},async has(k,ns){return this.lHas(k,ns)||(await this.iHas(k,ns));}};export default capi;